from ultralytics import YOLO
import torch
import torchvision
import time
import os

source = ' ' 
model = YOLO("")


image_files = [f for f in os.listdir(source) if f.endswith(('.jpg', '.jpeg', '.png'))]

for image_file in image_files:
    image_path = os.path.join(source, image_file)
    results = model(image_path, save=True, save_txt=True, conf=0.1, device='cuda:0')
    

    time.sleep(0.5)



               #This is the predict and filter for images in a storage bucket. Use with class name form so it knows what class to filter.

               
@app.route('/predict_filter', methods=['POST'])
def predict_and_filter_folder():
    class_name = request.form.get('class_name')
    if not class_name:
        return jsonify({'error': 'Class name is not provided.'}), 400
    try:
        class_name_int = int(class_name)
    except ValueError:
        return jsonify({'error': 'Class name must be a valid integer.'}), 400
    model = YOLO('/app/Model4600.pt')
    source_bucket_name = os.environ.get('SOURCE_BUCKET_NAME')
    destination_bucket_name = os.environ.get('DESTINATION_BUCKET_NAME')
    source_bucket = storage_client.bucket(source_bucket_name)
    destination_bucket = storage_client.bucket(destination_bucket_name)
    blobs = source_bucket.list_blobs()
    filtered_images = []
    for blob in blobs:
        if blob.name.lower().endswith(('.jpg', '.jpeg')):
            image_data = blob.download_as_bytes()
            image = Image.open(BytesIO(image_data))
            results = model(image, conf=0.01, device='cuda:0')
            boxes = results[0].boxes
            for box in boxes:
                if box.cls == class_name_int:
                    filtered_images.append(blob.name)
                    source_blob = source_bucket.blob(blob.name)
                    destination_blob = destination_bucket.blob(blob.name)
                    temp_image_path = f'/tmp/{blob.name}'
                    source_blob.download_to_filename(temp_image_path)
                    destination_blob.upload_from_filename(temp_image_path)
                    os.remove(temp_image_path)
                    break
    if not filtered_images:
        return jsonify({'message': 'No images matching the class name were found.'}), 404
    success_message = "The images have been filtered and saved to the destination bucket."
    return jsonify({'filtered_images': filtered_images,'message': success_message}), 200
